<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Revamping the test automation of a legacy mobile app</title>
  <link rel="stylesheet" href="/css/style.css">
</head>

<body class="case-study">
  <header>
    <h1>Revamping the test automation of a legacy mobile app</h1>
    <!-- <p>Case study of supporting the test automation team at King (makers of Candy Crush)</p> -->
  </header>

  <main>
    
<section id="overview">
    <div class="inner-section">
        <a class="back-link" href="/">Back to homepage</a>
        <h2>Overview</h2>
        <p>
            King, the creator of the <a href="https://www.king.com/game/candycrush" target="_blank">Candy Crush</a>
            franchise, is one of mobile gaming's most successful publishers, with its titles generating over $20 billion
            in lifetime revenue and hundreds of millions of downloads worldwide.
        </p>
        <p>
            They recruited me to support their test automation team of one of their flagship title that is more than 10
            years old.<br>
            I revamped the notification system to alert only the relevant engineers of test failures, and made the tests
            faster and less flaky.
        </p>
        <ul class="tags">
            <li><strong>Framework</strong>: Proprietary</li>
            <li><strong>Language</strong>: Java</li>
            <li><strong>CI/CD</strong>: Jenkins</li>
            <li><strong>Type</strong>: End-to-end tests</li>
        </ul>
    </div>
</section>

<section id="problem">
    <div class="inner-section">
        <h2>The Problem</h2>
        <p>
            There are not many tools to choose from when building test automation for video games. So everything needs
            to be
            built from scratch.<br>
            King is no exception and they built their own proprietary solution following a client/server architecture.
        </p>
        <h3>Wrong feedback from notifications</h3>
        <p>
            The first challenge was the amount of noise the engineering team was presented with. The pipeline was
            running
            multiple categories of tests for each platform, turning every change into dozens of slack notifications
            without
            a clear owner.
        </p>
        <h3>Flaky test running for too long</h3>
        <p>
            The second challenge was to optimize the tests themselves, both in terms of flakiness and speed.
        </p>
        <p>The test suite was regularly raising obscure errors without clear causes after long execution times.</p>
    </div>
</section>

<section id="actions">
    <div class="inner-section">
        <h2>My approach</h2>
        <h3>Tackling the noise generated by notifications</h3>
        <p>
            To improve the notifications, I made sure to bundle them into threads. All notifications relevant to a build
            could be found in a single thread. It was particularly useful to track the short term history of failing
            tests.
        </p>
        <p>
            Not all tests were relevant to the same engineering team. After bundling the notifications into threads, I
            split
            the different categories for relevant channels. This way only the engineers interested in these particular
            tests
            and their failures were seeing these results.
        </p>
        <p>
            This approach required heavy modifications of the CI pipeline (Jenkins). I had to rewrite a lot of the logic
            triggering the tests, and keeping track of the different channels for notifications to be sent to the right
            slack channel. These are skills that are often outside of what is expected of test automation.
        </p>
        <h3>Optimizing the tests</h3>
        <p>
            Video games are unusual apps, especially when it comes to testing them automatically. The UI is always
            different
            and there are no underlying standard allowing the tester to write robust test frameworks easily.<br>
            This result in a lot of flakiness.
        </p>
        <p>To tackle this problem I came up with multiple patterns that are applicable for any application, not just
            video
            games. I introduced the following best practices to the test automation team:
        <ul>
            <li><strong>Screen/Page objects:</strong> while there are no pages in video games, you can generalize the
                pattern at the screen or subscreen level to reuse code efficiently.</li>

            <li><strong>Explicit waits:</strong> a lot of problems when testing games come from synchronizing the
                application under test with the tests themselves. Writing custom explicit waits helps a lot with that.
                It
                clarifies what is waited for and helps failing early.</li>

            <li><strong>Checking the effect of interactions:</strong> Very often test automation engineers do not check
                the
                effect of the interactions they trigger. How do you know clicking on a button achieved what you
                expected?
                Unless you write the proper code for that, you might desynchronize your testing code with the
                application
                under test.<br>
                This is especially a problem in video games where input is often custom. But this is also applicable to
                other apps where custom widgets can have this problem.</li>
        </ul>
        </p>
        <p>Beyond flakiness one of my mission was to improve the tests speed. After validating some hypothesis, we
            decided
            to slowly move away from end-to-end tests running on real devices, and instead running them in VM where they
            can
            run faster with more stability.</p>
    </div>
</section>

<section id="results">
    <div class="inner-section">
        <h2>Results & Outcomes</h2>
        <h3>An improvement for engineers</h3>
        <p>
            Revamping notifications was a huge improvement for engineers. The noise turned into proper feedback they
            could
            act on. When a build failed, not only engineers were properly aware of the failure, but only the relevant
            teams
            got notified.<br>
            It made the test results clearer, and reduced the time needed to identify bugs.
        </p>
        <p>Since changing notifications required a lot of work inside the Jenkins infrastructure, I became the 3rd top
            committer overall on the CI/CD repository.</p>

        <h3>Reduction of test execution time</h3>
        <p>
            As for the introduction of best practices and moving away from real devices, it reduced the test execution
            time
            under and hour for the entire test suite.<br>
            Not only the tests took less time to execute, when they failed, they failed early and with proper error
            message,
            improving failure investigation.
        </p>
    </div>
</section>

    <section id="bottom">
      <div class="inner-section">
        <a class="back-link" href="/">Back to homepage</a>
      </div>
    </section>
  </main>

  <footer>
    Â© 2025 Romain Gauthier
</footer>

</body>

</html>